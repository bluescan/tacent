<dec f='Modules/Foundation/Inc/Foundation/tStandard.h' l='317' type='char32_t tStd::tUTF32c(const char8_t * srcPoint)'/>
<doc f='Modules/Foundation/Inc/Foundation/tStandard.h' l='294'>// Individual codepoint functions. If you want to convert to a single codepoint WITHOUT having a null terminator written
// the tUTFns functions above don&apos;t work (they write the terminator) and the tUTFn functions above are inconvenient
// since you&apos;d also need to provide the length.
//
// These tUTFnc functions fill the gap. They can take either a UTF-8/16/32 codeunit array (null terminated or not) and
// return a single UTF-32 encoded codepoint (and do not need the length as input). They can also take a UTF32 codepoint
// and convert to UTF-8/16/32 codeunit array without writing the null terminator. You can compose the two styles.
//
// The versions that take the codepoint as input may be used with a &apos;C++ character literal&apos; like U&apos;ğ’&apos;.
// Note that C++ character literals are constrained to what is representable by a single code unit. u8&apos;ğ’&apos; is not
// well-formed in C++ (even though it says u8, it does not mean you can put any unicode character in there). Basically
// u8&apos;&apos; must have an ASCII character, u&apos;&apos; must have a character in the BMP, and U can have pretty much anything. For
// this reason, there&apos;s not much point supporting u8 and u when U does it all. This is different than C++ STRING
// literals, where u8&quot;wÎ”ğ’&quot;, u&quot;wÎ”ğ’&quot;, and U&quot;wÎ”ğ’&quot; are all fine. (FYI w is ASCII, Î” is in the BMP. ğ’ is in an astral plane.)
//
// eg. tUTF8c(dst,  U&apos;ğ’&apos;)			 will return 4 and write 4 char8s into dst.
// eg. tUTF32c(u8&quot;ğ’&quot;)				 will return the UTF-32 codepoint for ğ’.
// eg. tUTF32c(U&quot;ğ’&quot;)				 will also return the UTF-32 codepoint for ğ’.
// eg. tUTF8c(dst, tUTF32c(u&quot;Î”&quot;))	will convert the UTF-16 encoding of Î” to a UTF-8 (non-null-terminated) array
//									and return how many UTF-8 code units are in the array.
//
// These read codeunit arrays and return a single codepoint in UTF-32. Special replacement returned on error. An error
// is either an invalid encoding OR when src is nullptr. Length is not needed as it&apos;s implicit in the encoding.</doc>
<doc f='Modules/Foundation/Inc/Foundation/tStandard.h' l='317'>// Reads 1 to 4 char8 codeunits from srcPoint.</doc>
<def f='Modules/Foundation/Src/tStandard.cpp' l='626' ll='634' type='char32_t tStd::tUTF32c(const char8_t * srcPoint)'/>
